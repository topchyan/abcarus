# ADR-0001: LibraryStore в renderer, LibraryService в main; без репликации state по IPC

Дата: 2 января 2026  
Статус: Accepted

## Контекст

В ABCarus библиотека (Tree + Modal) опирается на сканирование файловой системы, извлечение метаданных (discover), парсинг (parse) и операции записи (rename/move/bulk). При больших коллекциях узкое место быстро смещается не столько в вычисления, сколько в синхронизацию, объём данных и частоту событий между процессами Electron. Попытка держать канонический LibraryStore в main и “стримить” состояние в renderer неизбежно превращается в отдельный проект: диффы, версии state, восстановление при рассинхроне, дедупликация и контроль payload, иначе IPC становится медленным “кешем поверх медленного пайплайна”.

Нужно решение, которое минимизирует риск, сохраняет инварианты (tolerant-read/strict-write, транзакционность, throttling progress) и даёт понятный путь к discover/parse split и persisted index.

## Решение

Каноническое состояние UI-библиотеки (LibraryStoreState) находится в renderer. Все изменения UI-состояния происходят через LibraryActions в renderer.

В main находится LibraryService как узкий набор операций, близких к I/O: discover, parse-file, stat-guard, операции записи (атомарные), ведение persisted index (чтение/запись/миграции), политика X-policy для bulk на уровне “разрешить/запретить” и подготовительные проверки.

IPC используется как RPC (request/response) плюс ограниченный поток прогресса, обязательно throttled. Репликация/стриминг “живого store” по IPC не применяется.

Persisted index физически пишется и обслуживается в main (атомарно, версионированно), а в renderer только гидратируется через RPC-вызов (получение нужных фрагментов/срезов), после чего renderer обновляет свой store.

## Рассмотренные альтернативы

Альтернатива A: LibraryStore в main, renderer подписывается на диффы/снапшоты. Это повышает сложность, риск рассинхрона и нагрузку на IPC, особенно при крупных библиотеках и частых обновлениях.

Альтернатива B: Дублировать store в обоих процессах и “сводить” изменения. Это почти гарантированно приводит к расхождениям и неустранимым edge-case’ам при сбоях/гонках.

Выбранная модель (store в renderer, service в main) локализует сложность и оставляет IPC “тонким”.

## Последствия

Положительные: уменьшается риск IPC-блокировок; Tree/Modal получают единый источник истины в одном процессе; ускорители (persisted index) внедряются как оптимизация сервиса, не ломая контракт UI; упрощается вертикальный срез внедрения (openTune + parse-file через actions).

Негативные: renderer отвечает за консистентность UI-store и должен аккуратно обрабатывать конкурирующие запросы (например, параллельные openTune); потребуется дисциплина в проекте, чтобы никто не начинал “подпитывать” renderer скрытыми снапшотами огромных структур.

## Инварианты

tolerant-read/strict-write: чтение/сканирование терпимо к частичным данным и ошибкам; запись и массовые операции допускаются только при строгих проверках и предсказуемом результате.

Транзакционность: операции записи выполняются атомарно (temp + replace/rename с ретраями), с чёткими стадиями и откатом при ошибках; состояние в renderer обновляется только после подтверждённого результата от main.

Throttling progress: прогресс и события сканирования/парса никогда не отправляются “по событию на файл” без ограничения частоты; финальный сигнал завершения обязателен.

## Практическая реализация

Renderer реализует `LibraryActions.openTune()` как единственный путь открытия: резолв “намерения” → stat-guard/parse через LibraryService → обновление LibraryStore → передача данных в editor.

Main реализует `LibraryService.parseFile(path)` и `discover(path|roots)` как чистые I/O операции с контролем ошибок, с возможностью использования persisted index и инкрементального refresh.

Persisted index живёт в `userData`, имеет версию формата, атомарную запись и безопасный fallback на rebuild при любой несовместимости или повреждении.

## План миграции

Сначала вводится discover/parse режим и новые actions для openTune/parse-file, переводится Modal на чтение из renderer store и открытие только через actions. Затем подключается persisted index как ускоритель discover/parse. После этого постепенно переводятся rename/move/bulk и Tree на тот же store/actions, с включением транзакций и X-policy gating.

## Открытые вопросы

Нужно ли в перспективе поддерживать несколько окон/рендереров. Если да, это потребует отдельного ADR о модели синхронизации (скорее всего, через сервис-API и явную “сессию”, но без неконтролируемого стриминга state).

Нормализация ключей и путей для Windows/macOS должна быть отдельным техрешением (case-sensitivity, separators, long paths) и тестовым набором.

